## Vue源码

### 变化侦测

#### Object的变化侦测

> Object.defineProperty() 来观测对象数据的读和写

##### Observer类

- 调用`defineReactive`递归将一个对象所有属性都转化成可观测的对象
- 在其构造函数中给`value`新增一个`__ob__`属性，指向该`value`的`Observer`实例，可以避免重复操作
- 只有`object`类型的数据才会调用`walk`将每一个属性转换成`getter/setter`的形式来侦测变化

##### Dep类

> 谁用到了数据，谁就是依赖(watcher)，Dep来就是管理这些依赖的管理工具。并且在get中收集依赖，在set中通知依赖更新

- 在构造函数中创建了`subs`数组，用来存放依赖
- 定义了几个实例方法用来对依赖进行添加，删除，通知等操作

##### Watcher类

> 谁用到了数据，谁就是依赖，我们就为谁创建一个watcher实例，在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的`Watch`实例，由`Watcher`实例去通知真正的视图

![](E:\陈松年笔记\study-notes\imgs\watcher类工作流程.jpg)

##### 读流程

- `Data`通过`observer`转换成了`getter/setter`的形式来追踪变化。
- 当外界通过`Watcher`读取数据时，会触发`getter`从而将`Watcher`添加到依赖中。

##### 写流程

- 当数据发生了变化时，会触发`setter`，从而向`Dep`中的依赖（即Watcher）发送通知。
- `Watcher`接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。

#### Array的变化侦测

##### 收集依赖

- 数组的数据的依赖也在`getter`和`setter`中收集
- 在`defineReactive`函数中，首先获取数据对应的`Observer`实例`childOb`，然后在`getter`中调用`Observer`实例上依赖管理器，从而将依赖收集起来

##### 拦截器

> 在`Vue`中创建了一个数组方法拦截器，它拦截在数组实例与`Array.prototype`之间，在拦截器内重写了操作数组的一些方法，比如可以通知变化等

![](E:\陈松年笔记\study-notes\imgs\拦截器.png)

##### 通知依赖

> 我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖
>
> 我们只要能访问到被转化成响应式的数据`value`即可
>
> `vaule`上的`__ob__`就是其对应的`Observer`类实例，有了`Observer`类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的`dep.notify()`方法，让它去通知依赖更新即可

##### 深度监测

- 对于`Array`型数据，调用了`observeArray()`方法，该方法内部会遍历数组中的每一个元素，然后通过调用`observe`函数将每一个元素都转化成可侦测的响应式数据

##### 新增元素检测

- 如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据，操作是只需拿到新增的这个元素，然后调用`observe`函数将其转化即可

- 可以向数组内新增元素的方法有3个，分别是：`push`、`unshift`、`splice`，我们可以在这三个方法中分别处理即可

##### 不足之处？Vue.set和Vue.delete来救

> 我们在日常开发中，还可以通过数组的下标来操作数据，而这样的修改是无法被拦截器侦测到的，为了解决这一问题，`Vue`增加了两个全局API:`Vue.set`和`Vue.delete`