# 前端工程化

## 模块化

### CJS

`CJS` 是 `CommonJS` 的缩写，我们经常在`Node`中见到它

#### 关键词

- require：用于模块引入，是一个函数，所以是运行时加载，它可以接收一个`js`表达式，
- module：每一个模块都有，主要用于记录当前模块信息
- module.exports：用于模块导出，最终导出的结果，还是以`module.exports`指向的对象为准

#### 特点

- CommonJS模块是运行时加载，而且是同步加载，一般用在服务端，因为服务端读取的是本地资源，速度很快
- 模块可以多次加载，但是实际上只在第一次加载运行，后面都是使用缓存
- 模块输出是值的一个浅拷贝

#### 其它

- 默认情况下`exports`和`module.exports`指向是一样的，但是如果使用`module.exports = {}`的时候会重新创建一个新对象，这个时候两者的指向就不一样了，但是`CJS`总是以`module.exports`指向的对象为准，所以建议不要两者混用
- 在浏览器中不能运行，需要其他打包工具打包，在`package.json`中会以`main`字段为目标文件路径

### AMD

`AMD`的是`Asynchronous Module Definition`(异步模块定义)，`AMD`可以理解是`CJS`在浏览器端的解决方案，因为如果在浏览器总是同步加载的话可能会出现网络加载资源假死的情况，所以在浏览器是采用了异步加载的方案，因此`AMD`就是异步加载的

#### 关键词

- define：用于定义一个模块
- require：用于模块引入

#### 特点

- 体积更小，异步加载，按需加载，可以在浏览器端运行
- 不堵塞`js`线程运行

#### 其他

- 推荐使用`RequireJS`，目前是AMD规范最好的实现者之一

### CMD

`CMD`规范，全称`”Common Module Definition”`，称为 `通用模块加载规范`。它与`AMD很类似`，一般也是用在浏览器端。浏览器端异步加载库`Sea.js `实现的就是`CMD`规范

#### 特点

- `AMD`推崇依赖前置、也就是依赖要提前写好，而`CMD`推崇依赖就近的写法，用到了才写
- `AMD`一般来说是加载完立即执行，而`CMD`是延迟执行，推崇`as lazy as possible`

### UMD

`UMD` 代表通用模块定义（`Universal Module Definition`），准确来说并不是一个独立的模块标准，而是集合了`CJS`、`AMD`等一体的打包模式，会自动判断当前可用环境

#### 特点

- 一套代码，多端使用，模块化兼容性好
- 当使用 `Rollup/Webpack` 之类的打包器时，`UMD` 通常用作备用模块

### ESM

`ESM`是`ES6 Module`，`ES6`标准中的模块规则，一统浏览器和服务端标准的解决方案

#### 关键词

- import：用于模块的引入，只能接收字符串
- export：用于模块的导出

#### 特点

- 浏览器端会异步加载，这一点延续了`AMD`的优势，但是利用了浏览器原生的解析能力，代码体积更小
- `ESM`会有独立的静态解析阶段，`ESM`是编译时执行
- 模块内部自动采用严格模式，所以`this`的值为`undefined`，模块输出是值的引用，并且是只读的
- `import/export`提升： `import/export`必须位于模块顶级，不能位于作用域内；其次对于模块内的`import/export`会提升到模块顶部，这是在编译阶段完成的

#### 其他

- 在`package.json`中设置`"type": "module"` 才能开启`ESM`模式，会以`module`字段为目标文件路径

- 在静态分析阶段的时候，可以`Tree Shaking`，去除死代码，所谓静态分析, 就是在不运行代码的情况下, 对代码进行检测扫描分析

## 包管理器

### npm

> 这里说的是最早期的npm(v1/v2)

#### 介绍

`npm`的理念是：`Bring the best of open source to you, your team and your company.`

`npm（node package manager）`：`node.js`的包管理器，主要用于安装、卸载、管理、分享依赖或者框架

#### 早期的缺点

- `node_modules`是一层一层嵌套的，也就是依赖`A`可能还有依赖`B`，这样可能会依赖层级太深
- 依赖无法被公用，而且存在下载大量重复依赖，占用磁盘空间较大

### yarn

> yarn最初的出现主要就是解决npm早期的不足之处

#### 优点

- 确定性：采用`yarn.lock`机制，能够锁定安装的版本并提供确定性的依赖关系
- 模块扁平化：将不同版本的依赖包，按照一定的策略，归结为单个版本，避免冗余
- 网络性能更好：`yarn`采用了请求排队的理念，类似于并发池连接，能够更好的利用网络资源
- 采用缓存机制实现了离线模式

### pnpm

> pnpm本质上也是包管理器，这一点跟npm/yarn没有区别

#### 优点

- 包安装速度很快
- 利用软连接和硬连接使得磁盘空间利用非常高效
- 更安全，解决幽灵依赖问题
- 支持`monorepo`