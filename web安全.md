# web安全

## XSS

### 反射型XSS

反射型攻击一般是攻击方通过特定的手法，诱使用户去访问一个包含恶意代码的`URL`，然后进入网站执行恶意代码，反射型攻击可以窃取客户端的`cookie`或者钓鱼欺骗

### 存储型XSS

攻击者事先会将恶意脚本上传或者存储到服务器中，只要受害者浏览包含有这个恶意脚本都会被受到攻击，这种攻击是非常可怕的，可能会大量窃取`cookie`，这类的攻击一般出现在评论、留言、直播弹幕等地方

### DOM型XSS

`DOM`型攻击可以直接通过`HTTP`劫持，修改对应的`HTML`文件来实现恶意代码的注入

### 防御

- 将提交的包含有`JS`敏感字符进行转义，严格控制输入的字符串
- 对于不受信任的输入，都应该限定一个合理的长度
- 纯前端渲染，明确`innerText`、`setAttribute`、`style`，将代码与数据分隔开
- 不要一些不可信的数据传递到这些`API`，如 `eval()`、`onclick`、`onerror`、`onload`等
- 将`cookie`设置为`http-only`，`js`脚本将无法读取到`cookie`信息
- 严格的`CSP`，禁止加载外域代码、外域提交、内联脚本执行等较为严格的方式

## CSRF

### 原理

`CSRF`是跨站请求伪造的缩写，是一种劫持受信任的用户向服务器发送非预期的请求的攻击方式。通常情况下，`CSRF `攻击是攻击者借助受害者的`Cookie `骗取服务器的信任来达到在非授权的情况下执行权限保护之下的操作，比如发表评论、转账、支付等一系列操作。跟跨网站脚本`XSS`相比，`XSS`利用的是用户对指定网站的信任，`CSRF`利用的是网站对用户浏览器的信任

### 例子

- 小明登录了网站`A`，并且保留了`Cookie`
- 这个时候小明打开了带有攻击性代码的网站`B`，这个网站`B`会向网站`A`发送请求
- 网站`A`接收到请求后，对请求进行验证，并确认是受害者小明的凭证，误以为是受害者小明自己发送的请求
- 随后网站`A`响应了这个危险的请求，至此`CSRF`攻击完成

### 防御

#### 同源检测

使用同源策略进行限制来源网站，这样就可以知道是否是从本站发出的

##### 验证Origin字段

如果`Origin `存在，那么直接使用`Origin `中的字段确认来源域名就可以

##### 验证Referer字段

如果`Referer `存在，也可以用来确认`HTTP `请求的来源地址

#### 验证码

在一些敏感操作的地方可以添加验证码，验证码会强制用户必须与应用进行交互，才能完成最终请求，并且`CSRF`攻击是无法获取到验证码的

#### Token验证

在请求头中增加一个`Token`字段，首先浏览器是不会自动携带`Token`去请求的，并且`Token`会携带一段加密的`jwt`用作身份认证，那么这样进行`CSRF`攻击的时候就仅传递了`cookie`，并不能表明用户身份，网站即拒绝攻击请求

#### Cookie.SameSite

`Cookie `的`SameSite `属性用来限制第三方`Cookie`，从而减少安全风险，可以用来防止`CSRF `攻击和用户追踪

- Strict：最严格，跨站点时，任何情况下都不会发送`Cookie`
- Lax：规则稍微放宽一些
- None