## 计网

### 基础篇

#### 体系结构

##### OSI体系结构

- 应用层
- 表示层
- 会话层
- 运输层
- 网络层
- 数据链路层

##### TCP/IP体系结构

- 应用层
- 运输层
- 网络层
- 网络接口层

##### 原理体系结构

- 应用层
- 运输层
- 网络层
- 数据链路层
- 物理层

#### 原理体系结构详情

##### 应用层

应用层只需要专注于为用户提供应用服务，不需要关心数据是如何进行传输的，它只会将数据包给“快递员”负责，这个“快递员”就是运输层

##### 运输层(传输层)

> 传输层的任务就是负责传输数据，在传输层中，有两个重要的协议TCP和UDP

###### TCP协议

**提供面向连接的，可靠的数据传输服务**，数据的传输单位为**报文段**，在TCP协议中，如果数据吧大小超过MSS(TCP最大报文段长度)，就要把数据包分块传，每个分块叫做TCP段

###### UDP协议

**提供无连接的，尽最大努力（不可靠的）进行数据传输**，数据的传输单位是**用户数据段**

##### 网络层

> 实际上，传输层并不认真的从一个设备传输数据到另外一个设备上，传输层只是一个媒介，更好地服务应用层罢了，真正进行传输的是网络层，网络层最常用的是IP协议

###### IP协议

IP协议会将传输层产生的报文段数据与IP包头组成IP报文，如果IP报文太大超过了MTU，就会再次分片

###### IP协议的寻址和路由

IP 协议的寻址作用是告诉我们去往下⼀个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径。寻址更像在导航，路由更像在操作方向盘

##### 数据链路层

> 数据链路层的任务就是将分组从一端传送到另外一端，传送的数据单位为：帧。这个传输设备一般是路由器

路由器计算出下一个IP地址，再通过ARP协议找到目的地网卡的MAC地址，就知道该IP是哪个设备了

##### 物理层

物理层会将数据包转化为电信号，让其在物理介质中传输，它主要为数据链路层提供二进制传输任务

#### 原理体系结构(教科书)

##### 应用层

应用层：通过应用进程间的交互来实现特定网络应用，直接为用户或应用进程提供特定的应用服务，如文件传输、电子邮件等

##### 运输层

负责两台主机中进程之间的通信提供通用的数据传输服务。具体包括：复用与分用、可靠数据传输、流量控制、拥塞控制等

##### 网络层

负责为分组交换网上的不同主机提供通信服务。核心功能是逻辑编址、路由选择和分组转发

##### 数据链路层

在两个相邻结点间（主机和路由器或路由器和路由器之间）的链路上传送以帧为单位的数据。具体包括：组帧、差错控制、物理编址、接入控制、流量控制等

##### 物理层

在物理媒体上传送比特流。具体包括：与物理媒体的接口、比特的表示与同步、数据率、线路配置、物理拓扑等

### HTTP篇

#### HTTP基本概念题

##### HTTP是什么？

> HTTP全名为 超文本 传输 协议 ，HTTP协议是一个在计算机世界里专门在两点之间传输超文本数据的规定和规范

###### 超本文

一种超级文本，能包含文字、图片、视频等，具有超链接，能从一个超文本跳转到另外一个超文本

###### 传输

双向传输，允许中间有接力，但是要符合规定

###### 协议

为计算机之间的交流通信确立一种规范

##### 五大类常见HTTP状态码

- 1xx：属于**提示信息**，是一种协议处理的中间状态
- 2xx：表示服务器**成功**处理了客户端的请求
  - 200：**ok**，一切正常
  - 204：**no content**，成功，但是响应头没有body数据
  - 206：**partial content**，表示返回的body数据只是一部分

- 3xx：表示客户端请求的资源发生了变动，需要重定向
  - 301：**moved permanently**，表示永久重定向，说明请求资源已经不存在了，需要改用新的url访问
  - 302：**found**，表示临时重定向，说明请求的资源还在，但暂时需要另外一个url访问
  - 304：与浏览器缓存控制有关，状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据
- 4xx：表示客户端发送的报文有误，服务器无法处理（错误码）
  - 400：**bad request**，笼统的错误，表示客户端请求的报文有误
  - 401：**forbidden**，表示服务器禁止访问资源，并不是客户端的错误
  - 404：**not found**，表示请求的资源在服务器上找不到
- 5xx：表示客户端请求的报文正确，但是服务端内部出现了一些错误
  - 500：笼统的错误，表示服务器出错了
  - 501：**not implemented**，表示客户端请求的功能服务端还支持不了
  - 502：**bad getway**，通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，但是后端服务器发生了错误
  - 503：**service unavailable**，表示服务器当前很忙，暂时无法响应

##### 常见的HTTP请求头字段

- Accept:浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域（客户端发送请求时，用来指定服务器的域名）
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

##### 常见HTTP响应头字段

- Date：表示消息发送的时间，时间的描述格式由rfc822定义
- server:服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制HTTP缓存
- content-type:告诉客户端，本次数据是什么格式

#### HTTP 1.1 特性

##### 优点

- 简单：HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，便于理解
- 灵活和易扩展性：HTTP协议里的各类请求状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充
- 应用广泛和跨平台：HTTP的应用相当广泛，不管是PC端还是移动端都有大量使用

##### 缺点

- 无状态：服务器没有记忆能力，完成关联性的操作很麻烦，比如登录->下单->结账等都需要知道用户的身份，这一点可以通过`cookie`解决
- 明文传输：HTTP 的所有信息都暴露出来了，相当于信息裸奔，信息极有可能会被窃取
- 不安全：可能会被窃听（明文传输）、伪装（没有验证对方的身份）、篡改（报文被修改）

#### HTTP 1.1 性能

> `HTTP`是基于`TCP/IP`协议的，并且使用了`请求-应答`模式，关键点就在这里

##### 长连接（持久连接）

在早期的HTTP 1.0 中，浏览器每发送一次请求都要进行一次TCP连接，也就是三次握手和四次挥手，这是做了无谓的开销。在HTTP 1.1 中使用长连接的模式，只要任意一端没有明确提出断开连接，那么会保持TCP连接的状态

##### 管道传输

即可在同⼀个 TCP 连接里面，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第 二个请求出去，可以减少整体的响应时间，但是服务端响应还是会按照请求的顺序响应，也会存在队头阻塞

##### 队头阻塞

当请求队列的一个请求因为某种原因而得不到响应，也就是被阻塞的时候，会导致后面的请求也得不到服务端的回应，导致客户端一直请求不到数据，这就是队头阻塞，好比路上上班时候的堵车情况

#### HTTPS特性

> HTTPS解决了HTTP的不安全的问题，具体有：窃听风险、篡改风险、伪装风险

##### 混合加密

> 混合加密包括非对称加密和对称加密，它解决了信息风险

- 在通信建立前采用非对称加密的方式交换会话密钥，后续不再使用非对称加密的方式
- 在通信过程中采用对称加密的方式来加密数据

##### 摘要算法

> 摘要算法用来实现数据的完整性，能够为数据生成独一无二的指纹，能够解决篡改风险

客户端在发送明文之前会通过摘要算法计算出明文的指纹，然后发送的时候把明文和指纹一起加密打包发送给服务器，服务器接受到并且解密后，用相同的摘要算法计算出明文的指纹，通过比对看是否指纹一样，如果不一样则说明数据是不完整的

##### 数字证书

> 证书能保证服务端的身份是可信的，解决了伪装风险

服务器会把公钥放在数字证书里，只要证书是可信的，那么公钥也是可信的。因此可以通过CA证书的方式来保证服务器身份是可靠的，解决了伪装的风险

#### HTTP 3.0 

> HTTP 1.1 管道传输会存在队头阻塞。HTTP 2.0 多路复用时候，一旦发生丢包，就会阻塞HTTP的所有请求。造成这些的原因都是传输层TCP的问题。所以HTTP 3使用UDP来进行传输

##### 基于DDP的QUIC协议

> 我们都知道UDP传输是不可靠的，但基于DDP的QUIC协议也可以做到可靠传输的效果

- QUIC 有自己的⼀套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响
- TLS使用最新的1.3版本，头部压缩算法升级成了QPACK
- 对于HTTPS来说，建立一次连接需要6次交互，而QUIC把6次交互合并成了3次，减少了交互次数

### TCP篇

#### TCP头部格式分析

- 序列号：用来解决网络包乱序的问题
- 确认应答号：指的是下一次希望收到数据的序列号，用来解决丢包的问题
- 控制位：
  - ACK：该位为1时，确认应答字段变成有效，TCP规定除了初次建立连接以外，改位必须为1
  - RST：该位为1时，表示TCP连接出现异常必须强制断开连接
  - SYN：该位为1时，表示希望建立连接
  - FIN：该位为1时，表示以后不会再有数据发送，希望断开连接

### 区别题

#### Get和Post的区别

- 含义不同：`Get`方法的含义是向服务器获取资源；`Post`方法的含义是向`URL`指定的资源提交数据，数据就会放在`body`里

- 是否幂等：`Get`方法是幂等的，无论操作多少次，服务器上的数据都是安全的并且每次返回的数据也是相同的；`Post`方法是不幂等的，他会修改服务器上的数据
- 支持的参数类型不同：`Get`请求只能进行`url编码`；`Post`请求支持多种编码方式
- 长度限制：`Get`请求在URL中传送的参数是有长度限制的；`Post`请求没有
- 是否缓存：一般来说，浏览器会对`Get`请求进行缓存而`Post`不会

#### HTTP和HTTPS区别

- HTTP传输是明文传输，而HTTPS解决了HTTP的不安全的缺陷，它多了一个SSL/TLS安全协议，使得报文能进行加密传输
- HTTP只需要建立TCP三次握手后即可进行报文传输，而HTTPS还要进行SSL/TLS握手才能进行加密报文传输
- HTTPS需要CA证书，来保证服务器的身份是可信的，而HTTP没有
- HTTP的端口为80，而HTTPS的端口为443

#### HTTP 1.0 和 HTTP 1.1 区别

- 连接方面：HTTP 1.0 默认使用非持久连接，HTTP 1.1 默认使用持久连接
- 资源请求方面：HTTP 1.0 不支持断点续传功能，服务器会将整个对象送过来，而HTTP 1.1 允许只请求资源的某个部分，节省了宽带
- 缓存方面：HTTP 1.1 有了更多可供选择的缓存头来控制缓存
- 字段方面：HTTP 1.1 新增了host字段，用来指定服务器的域名
- 请求方面：HTTP 1.1 新增了PUT、HEAD等操作

#### HTTP 1.1 和 HTTP 2.0 区别

- 二进制格式：HTTP 1.1 报文是纯文本的，而HTTP 2.0 的报文全面采用二进制形式，并且统称为帧，分为头部帧和数据帧，对人可能不友好，但是对于计算机来说很友好，提高了数据传输的效率
- 头部压缩：HTTP1.1是无状态的，所以每次都必须附上所有的信息，因此有很多信息都是重复的。在HTTP 2.0，如果同时发送多个请求，那么协议会帮你消除重复的部分（HPACK），这样可以提高速度
- 数据流：HTTP 2.0提出了数据流的概念，因为HTTP 2.0 数据包并不是按照顺序进行发送的，同一个连接里面连续的数据包，可能属于不同的请求，因此必须要对数据包做标记，指出它是属于哪一个回应
- 多路复用：HTTP 2.0可以在一个连接中并发多个请求或者响应，而不用按照顺序一一对应，而HTTP 1.1 是串行请求的，还存在着队头阻塞的问题。HTTP 2.0的多路复用大大降低了延迟，大幅度提高了连接的利用率
- 服务器推送：服务器不再是被动的响应请求，它还可以主动推送一些资源给客户端

